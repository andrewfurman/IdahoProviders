### FILE TREE (SELECTED)

├─ upload_provider
|  ├─ templates
|  |  └─ upload_provider.html (27 lines)
|  └─ upload_provider_routes.py (9 lines)
|  ├─ image_to_markdown_gpt.py (4 lines)
├─ main.py (80 lines)


### FILE CONTENTS

FILE: upload_provider/templates/upload_provider.html
----------------------------------------

{% extends "header.html" %}

{% block content %}
<div class="py-8" style="padding-left: 20px; padding-right: 20px;">
    <div class="bg-white shadow rounded-lg p-6 max-w-4xl mx-auto">
        <h1 class="text-2xl font-bold mb-4">Upload Provider Data</h1>
        
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-6 text-center">
            <div class="text-6xl mb-4">📷</div>
            <h2 class="text-xl font-semibold mb-2">Coming Soon</h2>
            <p class="text-gray-600 mb-4">
                This page will allow you to upload images containing provider data. 
                The system will convert the images to text and load the provider information into the database.
            </p>
            <div class="text-sm text-gray-500">
                Check back later for this feature
            </div>
        </div>
        
        <div class="mt-8 pt-4 border-t">
            <a href="{{ url_for('providers.providers') }}" class="text-blue-600 hover:text-blue-800">← Back to Provider List</a>
        </div>
    </div>
</div>
{% endblock %}


FILE: upload_provider/upload_provider_routes.py
----------------------------------------

from flask import Blueprint, render_template

upload_provider_bp = Blueprint('upload_provider', __name__, template_folder='templates')

@upload_provider_bp.route('/upload')
def upload():
    return render_template('upload_provider.html')


FILE: upload_provider/image_to_markdown_gpt.py
----------------------------------------
# This function will intake an image and then it will send the image file to the ChatGPT API and then request that this ChatGPT API call return a markdown text that reflects all of the content of the image transcribed and structured just as the content is structured in the image or as close as possible to it.  So make sure to preserve any tables in markdown, make sure to preserve any header information or footer information and format it in markdown accordingly so that the markdown file maintains the same general structure as the image.  It doesn't need to be exact but just needs to be general.


OPENAI_API_KEY

FILE: main.py
----------------------------------------
from flask import Flask, redirect, url_for
from flask_sqlalchemy import SQLAlchemy
from flask_mail import Mail
from flask_login import LoginManager
from itsdangerous import URLSafeTimedSerializer
import os

# Initialize extensions
db = SQLAlchemy()
mail = Mail()
login_mgr = LoginManager()

app = Flask(__name__)

# ────────────────────────────────────────────────────────────────
# Core configuration
# ────────────────────────────────────────────────────────────────
# Database
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ["DATABASE_URL"]
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
    'pool_pre_ping': True,
    'pool_recycle': 300,  # Recycle connections every 5 minutes
    'pool_timeout': 30,   # Connection timeout of 30 seconds
    'pool_size': 10       # Maximum pool size
}

# Secrets ─── raise early if they're missing
try:
    app.config["FLASK_SECRET_KEY"] = os.environ["FLASK_SECRET_KEY"]
    app.config["SECURITY_TOKEN_SALT"] = os.environ["SECURITY_TOKEN_SALT"]
except KeyError as missing:
    raise ValueError(f"Required environment variable {missing} is not set")

# `app.secret_key` writes to app.config["SECRET_KEY"]; keep both for clarity
app.secret_key = app.config["FLASK_SECRET_KEY"]

# Mail (optional—but convenient to load here)
app.config["MAIL_SERVER"] = os.environ.get("MAIL_SERVER", "smtp.gmail.com")
app.config["MAIL_PORT"] = int(os.environ.get("MAIL_PORT", "587"))
app.config["MAIL_USE_TLS"] = os.environ.get("MAIL_USE_TLS", "true").lower() == "true"
app.config["MAIL_USERNAME"] = os.environ.get("MAIL_USERNAME")
app.config["MAIL_PASSWORD"] = os.environ.get("MAIL_PASSWORD")
app.config["MAIL_DEFAULT_SENDER"] = os.environ.get(
    "EMAILS_SENT_FROM", app.config["MAIL_USERNAME"]
)

# Initialize extensions with app
db.init_app(app)
mail.init_app(app)
login_mgr.init_app(app)

# Create URL safe serializer
ts = URLSafeTimedSerializer(
    secret_key=app.config["FLASK_SECRET_KEY"],
    salt=app.config["SECURITY_TOKEN_SALT"]
)

# ────────────────────────────────────────────────────────────────
# Blueprints & routes
# ────────────────────────────────────────────────────────────────
from providers.providers_routes import providers_bp
from auth import bp as auth_bp
from work_queues.work_queue_routes import wq_bp
from upload_provider.upload_provider_routes import upload_provider_bp

app.register_blueprint(auth_bp, url_prefix="/auth")
app.register_blueprint(providers_bp)
app.register_blueprint(wq_bp)
app.register_blueprint(upload_provider_bp)

@app.route("/")
def index():
    return redirect(url_for("upload_provider.upload"))

# ────────────────────────────────────────────────────────────────
# Entrypoint
# ────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

